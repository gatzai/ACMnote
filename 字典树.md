# 字典树
## 统计难题
```C++
#include <iostream>
#include <memory.h>
#include <cstring>
#define next a
using namespace std;
int next[500000][26],ans[500000]; //next数组为记录字母位置， ans记录字母个数
int root,l;
int newnode(){
	memset(next[l],-1,sizeof(next[l]));
	ans[l++]=0;
	return l-1;
}



void insert(char* str){
	int len=strlen(str),current=root;
	for(int i=0;i<len;i++){
		if(next[current][str[i]-'a']==-1){
			next[current][str[i]-'a']=newnode();		
		}
		current=next[current][str[i]-'a'];
		ans[current]++;
	}
}

int research(char* str){
	int len=strlen(str),current=root;
	for(int i=0;i<len;i++){
		current=next[current][str[i]-'a'];
		if(current==-1)
			return 0;
	}
	return ans[current];
}

int main(){
	l=0;
	root=newnode();
	char str[15];
	while(cin.getline(str,12)&&strlen(str)){
		insert(str);
	}
	while(cin.getline(str,12)&&strlen(str)){
		int ans=research(str);
		cout<<ans<<endl;
	}
	return 0;
}
```
```
比如：
input:
ab
cba
abc 
```
建表：

a|b|c
:----|:----|:----
1|-1|3
-1|2|-1
-1|4|6
5|-1|-1


index|0|1|2|3|4|5|6
:-|:-|:-|:-|:-|:-|:-|:-
ans|0|2|2|1|1|1|1

```
总结:
其实这个程序没有发现明显的树状结构，但其树状结构隐藏在二位数组里面，同位置的字母占用了相同的位置
(如：‘abc’和‘ab’的‘ab’占用了同一个next数组位置，只是ans数量改变了，其中c的开辟则要看看l加到多少),
可以看出程序处理的最漂亮的地方就是newnode()函数和变量‘l’的设置。以上
```

